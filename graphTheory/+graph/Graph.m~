classdef Graph
methods(Static = true)
function AdjMatrix = getGraph(topology, numNodes, degmax)
    import graph.*;
    %  Most of the following was copied from an implementation by pradeep ravikumar.
    if(isempty(degmax))
        degmax = (numNodes - 1);
    end
    
    AdjMatrix = logical(ones(numNodes, numNodes));
    AdjMatrix = AdjMatrix - diag(diag(AdjMatrix));
    
    switch topology
        case 'grid'
            %Grid Graph, 2D mesh
            gridSize = sqrt(numNodes);
            for i = 1:numNodes
                for j = (i+1):numNodes
                    if(Graph.noGridEdge(i,j,gridSize,gridSize))
                            AdjMatrix(i,j) = 0;
                            AdjMatrix(j,i) = 0;
                    end
                end
            end
        
        case '8ngrid'
            %Grid Graph, 2D mesh, 8 nn
            gridSize = sqrt(numNodes);
            for i = 1:numNodes
                for j = (i+1):numNodes
                    if(Graph.no8nGridEdge(i,j,gridSize,gridSize))
                            AdjMatrix(i,j) = 0;
                            AdjMatrix(j,i) = 0;
                    end
                end
            end
        
        case 'star'
            AdjMatrix = zeros(numNodes);
            sig = eye(numNodes);
            
            neighbors = 1 + randperm(numNodes-1);
            neighbors = neighbors(1:degmax);
            AdjMatrix(1,neighbors) = 1;
            AdjMatrix(neighbors,1) = 1;
            
        case 'tree1'
            %a specific tree or a random tree
            gridSize = sqrt(numNodes);
            AdjMatrix = zeros(numNodes,numNodes);
            for i = 1:gridSize
                    for j = 2:gridSize
                            cnode = gridSize * (i-1) + j;
                            pnode = cnode - 1;		
                            AdjMatrix(cnode,pnode) = 1;
                            AdjMatrix(pnode,cnode) = 1;
                    end
            end
            for i = 2:gridSize
                    pnode = gridSize * (i-1);
                    cnode = gridSize * i;
                    AdjMatrix(cnode,pnode) = 1;
                    AdjMatrix(pnode,cnode) = 1;
            end
        
        case 'chain'
            AdjMatrix = zeros(numNodes,numNodes);
            for i = 1:(numNodes-1)
                    AdjMatrix(i,i+1) = 1;
                    AdjMatrix(i+1,i) = 1;
            end

        case 'spade'
            AdjMatrix = Graph.getGraph('chain', numNodes, degmax);
            
    end %switch
    density = MatrixFunctions.getDensity(AdjMatrix);
    if(density <0.1)
        AdjMatrix = sparse(AdjMatrix);
    end
end

function nedge = no8nGridEdge(i,j,m,n)
    %  Most of the following was copied from an implementation by pradeep ravikumar.
    edge = false;
    if(mod(i,m) == 1)
        edge = (j == (i+1)) || (j == (i+m)) || (j == (i-m)) || (j == (i - m + 1)) || (j == (i +m + 1));
    else if(mod(i,m) == 0)
                edge = (j == (i-1)) || (j == (i+m)) || (j == (i-m)) || (j == (i - m - 1)) || (j == (i + m -1));
        else
                edge = (j == (i-1)) || (j == (i+1)) || (j == (i+m)) || (j == (i-m)) || (j == (i - m - 1)) || (j == (i + m -1)) || (j == (i - m + 1)) || (j == (i +m + 1));
        end
    end
    nedge = ~edge;
end

function nedge = noGridEdge(i,j,m,n)
    %  Most of the following was copied from an implementation by pradeep ravikumar.
    nedge = true;
    if(mod(i,m) == 1)
        nedge = ~((j == (i+1)) || (j == (i+m)) || (j == (i-m)));
    else if(mod(i,m) == 0)
            nedge = ~((j == (i-1)) || (j == (i+m)) || (j == (i-m)));
        else
            nedge = ~((j == (i+1)) || (j == (i-1)) || (j == (i+m)) || (j == (i-m)));
        end
    end
end

function bIsTree = isTree(topology)
    bIsTree = false;
    if(StringUtilities.isSubstring(topology, 'star') || StringUtilities.isSubstring(topology, 'chain') || StringUtilities.isSubstring(topology, 'tree'))
        bIsTree = true;
    end
end

function [extraEdgesInA, extraEdgesInB] = getDifference(AdjMatrixA, AdjMatrixB)
    import graph.*;
    % Input adjacency matrices are assumed to be symmetric.
    numEdgesInA = Graph.getNumEdges(AdjMatrixA);
    numEdgesInB = Graph.getNumEdges(AdjMatrixB);
    numCommonEdges = Graph.getNumEdges(AdjMatrixA & AdjMatrixB);
    extraEdgesInA = numEdgesInA - numCommonEdges;
    extraEdgesInB = numEdgesInB - numCommonEdges;
end

function numEdges = getNumEdges(AdjMatrix)
    if(size(AdjMatrix, 1) == size(AdjMatrix, 2))
        numEdges = full(sum(sum(triu(logical(AdjMatrix)) > 0)));
    else
        numEdges = full(sum(sum(logical(AdjMatrix) > 0)));
    end
end

end
end
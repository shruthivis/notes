\documentclass[oneside, article]{memoir}

\input{../packages}
\input{../packagesMemoir}
\input{../macros}

%opening
\title{Software: architecture, engineering: Survey}
\author{vishvAs vAsuki}

\begin{document}
\maketitle

\tableofcontents

\chapter{Themes and techniques}
For distributed computing, computer networks, software engineering, see elsewhere. Programming language concerns (including techniques like object oriented programming, functional programming etc..) are considered elsewhere.

Architecture considers how code may be organized.

\section{Engineering Process}
How to come up with better processes to get teams to churn out more reliable software with fewer resources?

\part{Art of Engineering software}
\chapter{The overall picture}
\section{Analogies}
Programming is a matter of unambiguously telling the computer what to do, in a language it understands.

Programming is analogous to wiring a complicated electronic circuit: Joining wires of various modules is the right way.

Programming is analogous to designing a pipeline or circuit on the computer (as in chip design or in designers like rational rose, or in rapidminer or in lego robotics).

\section{Understanding specifications}
In the industry, this involves surveying customers, rapid prototyping, talking to end-users etc.. In research, the specifications come from the research problem.

\chapter{Programming paradigms}
\section{Chapter Scope}
Programming language features enabling different programming paradigms and architectures are considered elsewhere. Eg: Higher order functions underlies functional programming paradigm.

\section{Imperative vs declarative programming}
\subsection{Imperative programming}
Views computation in terms of altering state.

\subsubsection{Structured programming}
In this programming paradigm, state changes are restricted locally. This helps organize code and state information. Structured programming code is more easily understood and maintainable than common procedural language code. This includes object oriented programming.

\subsection{Declarative programming}
Describes what needs to be done, rather than how to do it Eg: saying list.map(fn) instead of a C-like for-loop. Includes functional programming, logical programming.

The ideal of declarative programming is for the programmer to be able to express computation in terms of computation of a mathematical function - despite internally using imperative programming and dealing with memory at a lower level.


\section{Modularity With Object oriented programming}
\subsection{Encapsulation/ locality}
One collates within objects various values describing object-state. Often nouns correspond to objects, verbs to method calls.

For the sake of clarity, one may separate member variables from methods, creating two separate classes : ClassA and ClassABehavior.

\subsubsection{Member addition test}
Not every entity manipulated by an object need be its member - one may for example merely pass it as an argument to the object's methods.

To decide if an object should have a certain member, one way could be to ask the question: when a deep-copy of an object is made, is it proper that a copy of the member is made?

\subsection{Class relationships}
\subsubsection{Identifying shared code and state}
The fundamental operation in deciding the mechanism for code and state sharing between two objects is intersection - one determines precisely the state and methods that are to be shared.

\subsubsection{Sharing code and state}
Sharing state and associated methods between between two objects can be accomplished in two ways: class inheritence, aggregation/ containment (and sharing) of objects. The difference is the one between 'is-a' and 'has-a' relationships.

\subsubsection{Inheritence vs aggregation}
If objectA contains all of objectB, inheritence may be appropriate. In case multiple inheritence is necessary but the programming language won't allow it, one may use aggregation.

Sharing state and associated methods between between two objects can be accomplished in two ways: class inheritence, containment (and sharing) of objects.

\subsection{Add function interface to classes}
Called Type-class pattern because generic/ type-parametrized classes are used to solve the below problem.

\subsubsection{Problem}
Suppose that one wants to define a function $f$ whose arguments include objects of classes $C$ and $D$.

Suppose further that we want to define generic function $g$, which accepts objects of all classes with $f$ - without need of alteration as new classes with $f$ are defined.

Further, we want calls to $g$ to be type checked at compile-time.

\subsubsection{Inheritence}
A common way of implementing this is to add methods $C.f$ and $D.f$; and perhaps having them extend an interface $hasF$.

But, this may not be possible (because you don't have access to the source code of $C$ or $D$). Also, for various aesthetic reasons, you may not want $C$ and $D$ to be 'coupled' through an interface.

\subsubsection{Generic function use}
One can alternately define a generic function: $f[T]$, which can behave differently based on the class of its input - whether it is $C$ or $D$. This feat is often implemented using 'pattern matching' in case of algebraic data types.

The disadvantage of this is that type-checking usually happens at run-time, rather than at compile-time.

\subsubsection{Creating concrete fn objects with generic interfaces}
One can create a trait/ interface $hasF[T]$ where the function $f$ is defined, and create objects $C1$ and $D1$ which have the traits $hasF[C1]$ and $hasF[D1]$.

Then, $g[T]$ can be defined to accept $hasF[T]$.

If the programming language defines an 'implicit scope' whence arguments to functions may be drawn, one does not even need to pass these function objects explicitly.

\section{Functional programming paradigm}
\subsection{Introduction}
The main themes in functional programming languages are higher order and partially applied functions and functions without side effects.

\subsubsection{Facilitating parallel programming}
Absence of side effects (ie use of immutable data structures) eliminates problems such as race conditions arising out of shared memory.

Higher order functions - particularly those defined on lists - makes parallel programs easier to express.

\subsubsection{Computation as a vector function}
Let $D$ be the set of all scalars. Any computation can be specified as a vector function $f:D^{k_{in}} \to D^{k_{out}}$. We name the arguments to $f$ as $x_1, x_2 .. x_{k_{in}}$.

This function can in-turn be defined in terms of other simpler functions - using currying for example.

\subsection{Monad}
A monad is a generic object/ value which contains within it another value $v$ of type $t$. Apart from monad construction and ability to get the contained value, it contains the following basic functions:

map(f), which applies $f$ on $v$ and returns the resulting monad.


\subsubsection{None monad: error handling}
This construct is very useful in error handling: in case of an exception one can return a 'None' monad, for which map(f) has no effect.

\section{Exception handling}
Exception handling features which require special language features are explained in the programming languages survey.

\subsection{Error codes}
As in case of C, one may cause a function to exit abnormally in case of an exception, notifying the caller of the case by returning a special value, and setting a particular flag/ message in a memory location.

\subsection{Monads vs exception throwing}
Using monads is cleaner conceptually in its ability to write the program as a series of function operations. The resultant code is also more concise compared to the exception throwing paradigm.


\subsection{Advantages}
\subsubsection{Conciseness}
Very concise: fewer lines of code.

Fewer bugs. 

\subsubsection{Highly parallelizable}
For functions without dependencies, order can be reversed, plus there are no side-effects: Thread-safe.

So likely to become popular.


\chapter{Correct coding}

\chapter{Speedy coding}
Coding speed, in most applications, should not come at the cost of errors.

\section{Choosing programming languages}
One must use the language most appropriate language to solve the problem at hand quickly and with computational efficiency.

Sometimes, a tradeoff may be involved: tradeoff between expressiveness and efficiency of a language. One may even use different programming languages to specify different parts of the logic to the computer.

\subsection{Expressiveness/ conciseness}
Expressiveness is important in rapid prototyping/ programming.

Writing linear algebra logic in Java or C, for example, is far more tedious and cumbersome than using Matlab for the purpose, even in the presence of some good library functions: You end up worrying about low-level things like data representation and casting, rather than the linear algebra.

\subsubsection{Iteration}
Much of programming involves iteration.

Common operations and transformations on collections like Lists, Maps etc are much more efficient in functional languages like Scala than in C or Java. Idioms like map, filter, find, groupBy, indexWhere, zip, foreach reduce programming time significantly.

Freed from having to keep 'book-keeping' specifics in mind while programming, the programmer is happier to write code which considers all corner cases (rather than take shortcuts and state known bugs). The programmer can focus on algorithm-level optimizations and be more creative in general.

\section{Complexity}
More complex code is harder to implement : sometimes, there one can make choices which lead to simpler code - by simplifying requirements or interface languages for example.

\subsection{Cyclostomic complexity}
THis is the number of edges in a representation of a program as a flow chart. The more conditional and looping statements there are, the greater the cyclostomic complexity.

\section{Maintainability}
Constructs may need to be changed or extended in the future. Code written in the past should be easy to understand.

\subsection{Comments for enabling understandability}
So make comments and documentation copious.

When declaring (class) variables, write comments indicating purpose, desired properties.

When a particular design choice is implemented, comments may be included to justify the choice.

\subsection{Naming conventions}
Use good naming conventions for all identifiers. Use meaningful names; make it easy to read with capital letters at word beginnings: listIterator.

Macros and constants in CAPS.

Classes starting with capital letter. methods, objects, packagesMemoir start with small case. Maybe variable names prefixed to indicate data type.

In case of collections/ namespaces of multiple objects of type Str, the Java convention is to use the name str, rather than strs.

\subsection{Version control}
Use version control or just dropbox. \tbc

\subsection{Coding conventions}
\subitem Include sequence: Be alphabetical. In case of C++: mainHeader.h, c system, c++ system, other.

\subitem Terminate namespaces with // namespace video

\section{Automate tests}
In case of code to be shipped: test every function; make test scripts.

\subsection{Externalizing messages}
Message strings should, in most cases, not be hard-coded inside the code. Instead, message strings should be externalized; perhaps be returned by a function when provided with an appropriate key. 

This separates the program logic from the messages cleanly. One advantage of doing this is that these messages can be changed without touching the program logic.

This is also convenient when the program needs to be made available in several different languages.

\section{For research}
\subsection{Have a good library}
Don't rewrite the same logic multiple times: put it away in functions.

\subsection{Experiment functions}
Make a function out of each experiment.

Clearly make program variables for all parameters involved in the experiment. You should not have to comment or uncomment code to run different variations of the experiment; you should just set the experiment parameters as necessary.

\subsection{Automatic logging}
Corresponding to each experiment, create a log file with a time stamp automatically, perhaps of the same name.


\chapter{Writing efficient code}
Put theoretical analysis from algorithms and data structures to good use.

\section{Optimizing code for speed}
Use a profiler to detect parts of the code which are slow. Use libraries optimized for speed.

Avoid repeated memory allocation.

Avoid writing loops in interpreted languages without 'just in time compiling' facilities like Matlab: use a compiled language like C instead: otherwise interpretation costs for executing the code piles up.

\chapter{Group programming strategy}
\section{Pair programming}
Advantage is that you learn from your partner. Programming is more social, enjoyable; enthusiasm is maintained.

\part{Special software}
\chapter{Computer networks}
Considered in a separate survey.

\chapter{Operating systems}
Act as an interface between the various software jobs and the hardware.

Tasks include scheduling, memory management, disk management, handling i/o etc.

\section{Scheduling}
Swapping: must remember location of current instruction, memory contents etc..

\section{Threads}
There are threads/ processes. States: ready to be executed, executing, blocked: waiting for resource or a signal, terminated.

\subsection{Coordinating processes}
See distributed computing ref.

\chapter{User interfaces}
\section{GUI Metaphors}
The most common graphical user interfaces use the desktop/ workspace and the windows metaphor.

\subsection{Desktop}
A desktop/ workspace corresponds to a big area in the available screen space whence applications are launched, and within which statuses, widgets and windows are displayed.

There may be multiple workspaces on a device - especially in case of devices with limited screen size.

\subsubsection{Layering}
Various windows, widgets and the desktop conceptually form a stack of various displays available to the user. This concept is useful when understanding widgets.

\subsection{Taskbar, statusbar}
A narrow portion of the screen is sometimes dedicated to displaying the statuses of various running applications, outputs of widgets displaying info like time, weather etc..; and to provide place for menus to launch applications.

\subsection{Windows}
A window is an area of the screen which is dedicated as an input/ output interface. A window may be overlaid with another, or 'minimized' to have 0 screen area - and the corresponding area available for interaction with the window is correspondingly reduced. A window may be fully closed, possibly resulting in the termination of the corresponding application.

In case of small desktop workspaces (as in pocket computers), the active window occupies all of the available area on the workspace.

\subsubsection{Task switching}
Switching between windows is done using a program called 'task manager', which is generally invoked using the taskbar or special key combinations.

\subsection{Views and perspectives}
The Window is designed to be a collection of various views. Eg: Eclipse, RapidMiner. Perspectives are particular arrangements of certain views. UI's often allow (re)definition of perspectives by moving or adding views.

\subsection{Widget}
A widget is a window which is always on the layer  immediately above the desktop. So, whenever one views the desktop, the widget is necessarily seen on top of it. Unlike windows, they usually don't have simple means to close them.

\section{GUI Software Stack}
Graphical user interfaces are implemented using a stack of software. The software stack, with examples is as follows: 

\begin{itemize}
\item Windowing system: provides abstraction from hardware, provides graphics primitives, basic window drawing abilities. Eg: xorg server.
\item Login session manager. Enables selection of desktop environment. Eg: gdm, kdm, lxdm, simpledm.

\item Desktop environment. Eg: gnome, kde (programmed with widgeting toolkits gtk+ and qt respectively).
\subitem application ivocation: mouse driven or keyboard driven (possibly with autocompletion).
\subitem transferring copied content, drag/ drop.
\subitem Status panel showing useful updates like time, weather, input language.

\item Window managers. Eg: gnome-shell, compiz.
\subitem Responsible for: Working with multiple windows, switching between them, positioning them (possibly in different workspaces).

\end{itemize}

\subsection{Comparison}
Keyboard shortcuts for the above are jointly provided.

Various GUI software stacks differ in the facilities they provide. The penalty for greater facility comes in terms of memory and processing power used to merely provide the desktop environment.

\subsubsection{Look vs utility}
There is additional cost due to fashion - newer, heavier window managers are provided not just to provide greater facility, but to provide alternative looks favored by the hip crowd which is often not dense with power-users. Also, newer window managers could be experimental or unstable in many regards - eg: Ubuntu Unity  in 2011.

\section{Special input hardware}
\subsection{Buttons}
Buttons are often provided, dedicated for a simgle (possibly broad) purpose. These include buttons to power off, adjust volume, reset the computer etc.. They provide a useful, cheap ever-present way of accepting input from the user, which is partly why they are not located on the screen.

\subsection{Dials}
Dials - simulated or otherwise - are very useful for accepting numeric input; and are therefore provided in case of clocks, timers, etc..

\section{Special indicators}
\subsection{Lighted icons}
Sometimes lighted icons are provided to provided binary information about something. Eg: is the caps-lock on, is there a waiting notification.

\chapter{Logging systems}
Examples include various java logging frameworks including log4j.

\section{Requirements}
One is to be able to log at various levels, usually named debug, info, error etc..

Log messages should be informative and customizable: printing things like the name of the function where it originates, the class-name, the line number, the time, the log-message level etc..

Logging is to have a simple, yet expressive syntax for constructing messages.

One is to be able to set logging levels for various modules at various levels, so as to filter out relatively unimportant messages out of the log.

One is to be able to direct the log messages of various modules to arbitrary files, web-services or consoles.

\chapter{Domain specific languages (DSL)}
\section{Objectives}
The objective is often to define a special, simple language for a certain domain so as to provide a linguistic user interface usable by non-programmer domain-experts. This could also be an intermediate step for programmers ultimately providing other interfaces -  a paradigm called 'Language oriented programming'.

\section{Compiler implementation}
These are often written using high level functional languages like Scala, Groovy which let one define binary operators/ relations, easy type conversions, ways to dynamically handle arbitrary class members, syntax for symbols etc.. So, one actually writes DSL code which also makes sense in that high level language; and this code is interpreted suitably due to exploitation of the aforementioned features.

Binding symbols is often accomplished using hashmaps.

\chapter{Compilers}
\tbc

% \bibliographystyle{plain}
% \bibliography{randomizedAlgorithms}

\end{document}
